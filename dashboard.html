<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blueprint Architect | Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c2461 0%, #1e3799 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }
        
        .user-info {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .user-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #3498db, #2ecc71);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }
        
        .logout-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .logo-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #3498db, #2ecc71);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tagline {
            color: #7f8c8d;
            font-size: 1.2rem;
            font-weight: 300;
            letter-spacing: 0.5px;
        }
        
        .welcome-message {
            color: #4a00e0;
            font-size: 1.1rem;
            margin-top: 10px;
            font-weight: 500;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .input-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .panel-title {
            color: #2c3e50;
            font-size: 1.8rem;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #3498db;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title i {
            color: #3498db;
        }
        
        .input-section {
            margin-bottom: 30px;
        }
        
        .section-title {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-with-icon {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .input-icon {
            position: absolute;
            left: 15px;
            color: #7f8c8d;
            font-size: 1.2rem;
        }
        
        input, select {
            width: 100%;
            padding: 15px 15px 15px 45px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
        }
        
        input:focus, select:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
            outline: none;
        }
        
        .orientation-section {
            margin-top: 30px;
        }
        
        .orientation-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .orientation-btn {
            padding: 18px;
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .orientation-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .orientation-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .orientation-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .generate-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }
        
        .generate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(46, 204, 113, 0.4);
            background: linear-gradient(135deg, #27ae60, #219653);
        }
        
        .generate-btn:active {
            transform: translateY(-1px);
        }
        
        .blueprint-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
        }
        
        .blueprint-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .blueprint-title {
            color: #2c3e50;
            font-size: 1.8rem;
        }
        
        .generation-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: #f8f9fa;
            border-radius: 50px;
            font-weight: 500;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #2ecc71;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        .blueprint-container {
            flex: 1;
            background: #f8f9fa;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            border: 2px dashed #d0d0d0;
            min-height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #blueprint-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .generation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: opacity 0.5s ease;
        }
        
        .generation-animation {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .animation-circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 4px solid transparent;
            border-top-color: #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        .animation-circle:nth-child(2) {
            border-top-color: #2ecc71;
            animation-delay: 0.2s;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
        }
        
        .animation-circle:nth-child(3) {
            border-top-color: #9b59b6;
            animation-delay: 0.4s;
            width: 50%;
            height: 50%;
            top: 25%;
            left: 25%;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .generation-text {
            font-size: 1.5rem;
            color: #2c3e50;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .generation-subtext {
            color: #7f8c8d;
            text-align: center;
            max-width: 300px;
        }
        
        .blueprint-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 25px;
        }
        
        @media (max-width: 768px) {
            .blueprint-details {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        .detail-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        
        .detail-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .detail-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        .detail-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            font-weight: 500;
        }
        
        .compass {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #2c3e50;
            z-index: 5;
            border: 2px solid #3498db;
        }
        
        .compass::after {
            content: 'N';
            position: absolute;
            top: -15px;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .water-mark {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(52, 152, 219, 0.1);
            font-size: 4rem;
            font-weight: bold;
            pointer-events: none;
            user-select: none;
        }
        
        footer {
            text-align: center;
            padding: 25px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            color: #7f8c8d;
            font-size: 0.9rem;
            margin-top: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .footnote {
            margin-top: 10px;
            font-style: italic;
            color: #95a5a6;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="user-info">
                <div class="user-avatar" id="userAvatar">U</div>
                <button class="logout-btn" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i> Logout
                </button>
            </div>
            
            <div class="logo">
                <div class="logo-icon">
                    <i class="fas fa-drafting-compass"></i>
                </div>
                <div>
                    <h1>Blueprint Architect</h1>
                    <p class="tagline">Transform your land dimensions into professional architectural blueprints</p>
                    <p class="welcome-message" id="welcomeMessage">Welcome back, User!</p>
                </div>
            </div>
        </header>
        
        <div class="main-content">
            <div class="input-panel">
                <h2 class="panel-title">
                    <i class="fas fa-ruler-combined"></i> Land Specifications
                </h2>
                
                <div class="input-section">
                    <h3 class="section-title">
                        <i class="fas fa-expand-alt"></i> Dimensions
                    </h3>
                    <div class="dimension-inputs">
                        <div class="input-group">
                            <label>Length (ft)</label>
                            <div class="input-with-icon">
                                <div class="input-icon">
                                    <i class="fas fa-ruler-horizontal"></i>
                                </div>
                                <input type="number" id="length" min="10" max="500" value="60" placeholder="Enter length">
                            </div>
                        </div>
                        
                        <div class="input-group">
                            <label>Width (ft)</label>
                            <div class="input-with-icon">
                                <div class="input-icon">
                                    <i class="fas fa-ruler-vertical"></i>
                                </div>
                                <input type="number" id="width" min="10" max="500" value="40" placeholder="Enter width">
                            </div>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label>Total Area</label>
                        <div class="input-with-icon">
                            <div class="input-icon">
                                <i class="fas fa-calculator"></i>
                            </div>
                            <input type="number" id="area" min="100" max="100000" value="2400" placeholder="Enter area" readonly>
                        </div>
                        <div style="font-size: 0.9rem; color: #7f8c8d; margin-top: 5px;">
                            <i class="fas fa-info-circle"></i> Area is calculated automatically from length × width
                        </div>
                    </div>
                </div>
                
                <div class="input-section orientation-section">
                    <h3 class="section-title">
                        <i class="fas fa-compass"></i> Orientation
                    </h3>
                    <p style="margin-bottom: 15px; color: #5d6d7e;">
                        Select the main facing direction of your property:
                    </p>
                    
                    <div class="orientation-buttons">
                        <div class="orientation-btn" data-orientation="north">
                            <div class="orientation-icon">
                                <i class="fas fa-arrow-up"></i>
                            </div>
                            <div>North Facing</div>
                            <div class="detail-label">Most sunlight in back</div>
                        </div>
                        
                        <div class="orientation-btn" data-orientation="south">
                            <div class="orientation-icon">
                                <i class="fas fa-arrow-down"></i>
                            </div>
                            <div>South Facing</div>
                            <div class="detail-label">Sunlight throughout day</div>
                        </div>
                        
                        <div class="orientation-btn active" data-orientation="east">
                            <div class="orientation-icon">
                                <i class="fas fa-arrow-right"></i>
                            </div>
                            <div>East Facing</div>
                            <div class="detail-label">Morning sunlight</div>
                        </div>
                        
                        <div class="orientation-btn" data-orientation="west">
                            <div class="orientation-icon">
                                <i class="fas fa-arrow-left"></i>
                            </div>
                            <div>West Facing</div>
                            <div class="detail-label">Afternoon sunlight</div>
                        </div>
                    </div>
                </div>
                
                <div class="input-section">
                    <h3 class="section-title">
                        <i class="fas fa-home"></i> Structure Type
                    </h3>
                    <div class="input-group">
                        <div class="input-with-icon">
                            <div class="input-icon">
                                <i class="fas fa-building"></i>
                            </div>
                            <select id="structureType">
                                <option value="residential">Residential House</option>
                                <option value="office">Office Building</option>
                                <option value="apartment">Apartment Complex</option>
                                <option value="warehouse">Warehouse</option>
                                <option value="custom">Custom Design</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <button id="generateBtn" class="generate-btn">
                    <i class="fas fa-magic"></i> Generate Innovative Blueprint
                </button>
            </div>
            
            <div class="blueprint-panel">
                <div class="blueprint-header">
                    <h2 class="blueprint-title">Architectural Blueprint</h2>
                    <div class="generation-status">
                        <div class="status-indicator"></div>
                        <span>Ready to Generate</span>
                    </div>
                </div>
                
                <div class="blueprint-container">
                    <div class="generation-overlay" id="generationOverlay">
                        <div class="generation-animation">
                            <div class="animation-circle"></div>
                            <div class="animation-circle"></div>
                            <div class="animation-circle"></div>
                        </div>
                        <div class="generation-text">Crafting Your Blueprint</div>
                        <div class="generation-subtext" id="generationStep">Analyzing dimensions and orientation...</div>
                    </div>
                    
                    <div class="water-mark">BLUEPRINT</div>
                    <div class="compass" id="compass">E</div>
                    <canvas id="blueprint-canvas"></canvas>
                </div>
                
                <div class="blueprint-details">
                    <div class="detail-card">
                        <div class="detail-value" id="detail-length">60 ft</div>
                        <div class="detail-label">Length</div>
                    </div>
                    <div class="detail-card">
                        <div class="detail-value" id="detail-width">40 ft</div>
                        <div class="detail-label">Width</div>
                    </div>
                    <div class="detail-card">
                        <div class="detail-value" id="detail-area">2,400 sqft</div>
                        <div class="detail-label">Total Area</div>
                    </div>
                    <div class="detail-card">
                        <div class="detail-value" id="detail-rooms">5</div>
                        <div class="detail-label">Recommended Rooms</div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>© 2023 Blueprint Architect | This is a conceptual visualization tool. For actual construction, consult with a licensed architect.</p>
            <p class="footnote">Designs are generated algorithmically based on architectural best practices and orientation principles.</p>
        </footer>
    </div>

    <script>
        // Check if user is logged in
        window.addEventListener('load', () => {
            const isLoggedIn = localStorage.getItem('isLoggedIn');
            const username = localStorage.getItem('username');
            
            if (isLoggedIn !== 'true') {
                // Redirect to login page if not logged in
                window.location.href = 'login.html';
                return;
            }
            
            // Update welcome message and avatar
            if (username) {
                document.getElementById('welcomeMessage').textContent = `Welcome back, ${username}!`;
                document.getElementById('userAvatar').textContent = username.charAt(0).toUpperCase();
            }
        });
        
        // Logout functionality
        document.getElementById('logoutBtn').addEventListener('click', () => {
            // Clear login state
            localStorage.removeItem('isLoggedIn');
            localStorage.removeItem('username');
            
            // Show logout message
            alert('You have been logged out. Redirecting to login page...');
            
            // Redirect to login page
            window.location.href = 'login.html';
        });
        
        // DOM Elements for blueprint functionality
        const lengthInput = document.getElementById('length');
        const widthInput = document.getElementById('width');
        const areaInput = document.getElementById('area');
        const generateBtn = document.getElementById('generateBtn');
        const orientationButtons = document.querySelectorAll('.orientation-btn');
        const structureTypeSelect = document.getElementById('structureType');
        const blueprintCanvas = document.getElementById('blueprint-canvas');
        const ctx = blueprintCanvas.getContext('2d');
        const generationOverlay = document.getElementById('generationOverlay');
        const generationStep = document.getElementById('generationStep');
        const compass = document.getElementById('compass');
        
        // Display elements
        const detailLength = document.getElementById('detail-length');
        const detailWidth = document.getElementById('detail-width');
        const detailArea = document.getElementById('detail-area');
        const detailRooms = document.getElementById('detail-rooms');
        
        // Variables
        let currentOrientation = 'east';
        let isGenerating = false;
        let generationSteps = [
            "Analyzing dimensions and orientation...",
            "Calculating optimal room layout...",
            "Applying architectural principles...",
            "Incorporating sunlight patterns...",
            "Designing innovative floor plan...",
            "Adding structural elements...",
            "Finalizing blueprint details..."
        ];
        let currentStep = 0;
        
        // Initialize event listeners
        function initEventListeners() {
            // Calculate area when dimensions change
            lengthInput.addEventListener('input', updateArea);
            widthInput.addEventListener('input', updateArea);
            
            // Orientation buttons
            orientationButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    orientationButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentOrientation = this.getAttribute('data-orientation');
                    compass.textContent = currentOrientation.charAt(0).toUpperCase();
                    updateDetails();
                });
            });
            
            // Generate blueprint
            generateBtn.addEventListener('click', generateBlueprint);
            
            // Update details on structure type change
            structureTypeSelect.addEventListener('change', updateDetails);
            
            // Handle window resize
            window.addEventListener('resize', resizeCanvas);
        }
        
        // Calculate and update area
        function updateArea() {
            const length = parseFloat(lengthInput.value) || 0;
            const width = parseFloat(widthInput.value) || 0;
            const area = length * width;
            
            areaInput.value = area;
            updateDetails();
            
            // Auto-generate if both values are valid
            if (length >= 10 && width >= 10) {
                drawBlueprint();
            }
        }
        
        // Update detail displays
        function updateDetails() {
            const length = parseFloat(lengthInput.value) || 0;
            const width = parseFloat(widthInput.value) || 0;
            const area = length * width;
            const structureType = structureTypeSelect.value;
            
            // Calculate recommended rooms based on area and structure type
            let rooms = 3;
            if (area > 1500) rooms = 4;
            if (area > 2500) rooms = 5;
            if (area > 4000) rooms = 7;
            if (area > 8000) rooms = 10;
            
            if (structureType === 'office') rooms = Math.max(3, Math.floor(area / 500));
            if (structureType === 'apartment') rooms = Math.max(6, Math.floor(area / 400));
            if (structureType === 'warehouse') rooms = 2;
            
            detailLength.textContent = `${length} ft`;
            detailWidth.textContent = `${width} ft`;
            detailArea.textContent = area.toLocaleString() + ' sqft';
            detailRooms.textContent = rooms;
        }
        
        // Resize canvas
        function resizeCanvas() {
            const container = blueprintCanvas.parentElement;
            blueprintCanvas.width = container.clientWidth;
            blueprintCanvas.height = container.clientHeight;
            if (!isGenerating) {
                drawBlueprint();
            }
        }
        
        // Show generation animation
        function showGenerationAnimation() {
            isGenerating = true;
            generationOverlay.style.opacity = '1';
            generationOverlay.style.pointerEvents = 'all';
            currentStep = 0;
            
            // Update generation steps
            const interval = setInterval(() => {
                generationStep.textContent = generationSteps[currentStep];
                currentStep = (currentStep + 1) % generationSteps.length;
            }, 800);
            
            return interval;
        }
        
        // Hide generation animation
        function hideGenerationAnimation(interval) {
            setTimeout(() => {
                generationOverlay.style.opacity = '0';
                generationOverlay.style.pointerEvents = 'none';
                clearInterval(interval);
                isGenerating = false;
            }, 3000);
        }
        
        // Generate blueprint with animation
        function generateBlueprint() {
            const length = parseFloat(lengthInput.value) || 60;
            const width = parseFloat(widthInput.value) || 40;
            
            if (length < 10 || width < 10) {
                alert("Please enter valid dimensions (minimum 10 feet each)");
                return;
            }
            
            // Show generation animation
            const interval = showGenerationAnimation();
            
            // Update status
            document.querySelector('.generation-status span').textContent = 'Generating...';
            
            // Generate blueprint after animation
            setTimeout(() => {
                drawBlueprint();
                hideGenerationAnimation(interval);
                
                // Update status
                setTimeout(() => {
                    document.querySelector('.generation-status span').textContent = 'Blueprint Ready';
                }, 500);
            }, 3000);
        }
        
        // Draw the innovative blueprint
        function drawBlueprint() {
            // Clear canvas
            ctx.clearRect(0, 0, blueprintCanvas.width, blueprintCanvas.height);
            
            // Get values
            const length = parseFloat(lengthInput.value) || 60;
            const width = parseFloat(widthInput.value) || 40;
            const area = length * width;
            const structureType = structureTypeSelect.value;
            
            // Set drawing parameters
            const padding = 50;
            const maxWidth = blueprintCanvas.width - padding * 2;
            const maxHeight = blueprintCanvas.height - padding * 2;
            
            // Calculate scale to fit canvas
            const scale = Math.min(maxWidth / length, maxHeight / width);
            const scaledLength = length * scale;
            const scaledWidth = width * scale;
            
            // Center the drawing
            const startX = (blueprintCanvas.width - scaledLength) / 2;
            const startY = (blueprintCanvas.height - scaledWidth) / 2;
            
            // Draw background with gradient
            const bgGradient = ctx.createLinearGradient(0, 0, blueprintCanvas.width, blueprintCanvas.height);
            bgGradient.addColorStop(0, '#f8f9fa');
            bgGradient.addColorStop(1, '#e8f4fc');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(startX, startY, scaledLength, scaledWidth);
            
            // Draw innovative grid pattern
            drawInnovativeGrid(startX, startY, scaledLength, scaledWidth, scale);
            
            // Draw property boundary
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            ctx.strokeRect(startX, startY, scaledLength, scaledWidth);
            
            // Draw orientation arrow
            drawOrientationArrow(startX, startY, scaledLength, scaledWidth);
            
            // Draw architectural design based on structure type
            drawArchitecturalDesign(startX, startY, scaledLength, scaledWidth, structureType, area);
            
            // Draw dimension markers
            drawDimensionMarkers(startX, startY, scaledLength, scaledWidth, length, width);
            
            // Draw title and details
            drawBlueprintInfo(startX, startY, scaledLength, scaledWidth, length, width, area);
        }
        
        // Draw innovative grid pattern
        function drawInnovativeGrid(startX, startY, length, width, scale) {
            ctx.strokeStyle = 'rgba(52, 152, 219, 0.2)';
            ctx.lineWidth = 1;
            
            // Draw diagonal grid
            const gridSize = 10 * scale;
            for (let x = startX; x <= startX + length; x += gridSize) {
                for (let y = startY; y <= startY + width; y += gridSize) {
                    if ((x + y) % (gridSize * 2) === 0) {
                        ctx.fillStyle = 'rgba(52, 152, 219, 0.05)';
                        ctx.fillRect(x, y, gridSize, gridSize);
                    }
                }
            }
            
            // Draw cross pattern
            ctx.strokeStyle = 'rgba(46, 204, 113, 0.1)';
            ctx.beginPath();
            for (let x = startX + gridSize/2; x < startX + length; x += gridSize) {
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + width);
            }
            for (let y = startY + gridSize/2; y < startY + width; y += gridSize) {
                ctx.moveTo(startX, y);
                ctx.lineTo(startX + length, y);
            }
            ctx.stroke();
        }
        
        // Draw orientation arrow
        function drawOrientationArrow(startX, startY, length, width) {
            const centerX = startX + length / 2;
            const centerY = startY + width / 2;
            const arrowSize = Math.min(length, width) * 0.1;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Rotate based on orientation
            let rotation = 0;
            if (currentOrientation === 'north') rotation = -Math.PI/2;
            if (currentOrientation === 'south') rotation = Math.PI/2;
            if (currentOrientation === 'east') rotation = 0;
            if (currentOrientation === 'west') rotation = Math.PI;
            ctx.rotate(rotation);
            
            // Draw arrow
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(0, -arrowSize);
            ctx.lineTo(arrowSize/2, 0);
            ctx.lineTo(-arrowSize/2, 0);
            ctx.closePath();
            ctx.fill();
            
            // Draw direction text
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(currentOrientation.toUpperCase(), 0, arrowSize + 15);
            
            ctx.restore();
        }
        
        // Draw architectural design based on structure type
        function drawArchitecturalDesign(startX, startY, length, width, structureType, area) {
            ctx.strokeStyle = '#3498db';
            ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.lineWidth = 2;
            
            if (structureType === 'residential') {
                drawResidentialDesign(startX, startY, length, width, area);
            } else if (structureType === 'office') {
                drawOfficeDesign(startX, startY, length, width, area);
            } else if (structureType === 'apartment') {
                drawApartmentDesign(startX, startY, length, width, area);
            } else if (structureType === 'warehouse') {
                drawWarehouseDesign(startX, startY, length, width, area);
            } else {
                drawCustomDesign(startX, startY, length, width, area);
            }
        }
        
        // Draw residential design
        function drawResidentialDesign(startX, startY, length, width, area) {
            const roomCount = Math.max(3, Math.floor(area / 600));
            
            // Main building
            const buildingWidth = length * 0.7;
            const buildingHeight = width * 0.6;
            const buildingX = startX + (length - buildingWidth) / 2;
            const buildingY = startY + (width - buildingHeight) / 2;
            
            ctx.fillStyle = 'rgba(52, 152, 219, 0.15)';
            ctx.fillRect(buildingX, buildingY, buildingWidth, buildingHeight);
            ctx.strokeRect(buildingX, buildingY, buildingWidth, buildingHeight);
            
            // Draw rooms
            const roomsPerRow = Math.ceil(Math.sqrt(roomCount));
            const roomWidth = buildingWidth / roomsPerRow;
            const roomHeight = buildingHeight / Math.ceil(roomCount / roomsPerRow);
            
            let roomIndex = 0;
            const roomLabels = ['Living', 'Kitchen', 'Bed 1', 'Bed 2', 'Bath', 'Office', 'Bed 3', 'Dining'];
            
            for (let row = 0; row < Math.ceil(roomCount / roomsPerRow); row++) {
                for (let col = 0; col < roomsPerRow && roomIndex < roomCount; col++) {
                    const roomX = buildingX + col * roomWidth;
                    const roomY = buildingY + row * roomHeight;
                    
                    // Draw room
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(roomX, roomY, roomWidth, roomHeight);
                    
                    // Add room label
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(roomLabels[roomIndex % roomLabels.length], 
                                roomX + roomWidth/2, roomY + roomHeight/2);
                    
                    // Draw door
                    ctx.fillStyle = '#8e44ad';
                    if (row === 0 && col === Math.floor(roomsPerRow/2)) {
                        // Front door
                        ctx.fillRect(roomX + roomWidth/2 - 5, roomY - 2, 10, 8);
                    }
                    
                    roomIndex++;
                }
            }
            
            // Draw driveway based on orientation
            drawDriveway(startX, startY, length, width, buildingX, buildingY, buildingWidth, buildingHeight);
            
            // Draw garden/lawn area
            ctx.fillStyle = 'rgba(46, 204, 113, 0.1)';
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 1;
            
            // Front lawn
            if (currentOrientation === 'north') {
                ctx.fillRect(startX, startY, length, (width - buildingHeight)/2);
                ctx.strokeRect(startX, startY, length, (width - buildingHeight)/2);
            } else if (currentOrientation === 'south') {
                ctx.fillRect(startX, buildingY + buildingHeight, length, (width - buildingHeight)/2);
                ctx.strokeRect(startX, buildingY + buildingHeight, length, (width - buildingHeight)/2);
            } else if (currentOrientation === 'east') {
                ctx.fillRect(buildingX + buildingWidth, startY, (length - buildingWidth)/2, width);
                ctx.strokeRect(buildingX + buildingWidth, startY, (length - buildingWidth)/2, width);
            } else {
                ctx.fillRect(startX, startY, (length - buildingWidth)/2, width);
                ctx.strokeRect(startX, startY, (length - buildingWidth)/2, width);
            }
        }
        
        // Draw driveway based on orientation
        function drawDriveway(startX, startY, plotLength, plotWidth, buildingX, buildingY, buildingWidth, buildingHeight) {
            ctx.fillStyle = '#95a5a6';
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2;
            
            const drivewayWidth = Math.min(plotLength, plotWidth) * 0.15;
            
            if (currentOrientation === 'north') {
                // Driveway from north side
                const drivewayX = buildingX + buildingWidth/2 - drivewayWidth/2;
                const drivewayY = startY;
                const drivewayHeight = buildingY - startY;
                
                ctx.fillRect(drivewayX, drivewayY, drivewayWidth, drivewayHeight);
                ctx.strokeRect(drivewayX, drivewayY, drivewayWidth, drivewayHeight);
                
            } else if (currentOrientation === 'south') {
                // Driveway from south side
                const drivewayX = buildingX + buildingWidth/2 - drivewayWidth/2;
                const drivewayY = buildingY + buildingHeight;
                const drivewayHeight = (startY + plotWidth) - (buildingY + buildingHeight);
                
                ctx.fillRect(drivewayX, drivewayY, drivewayWidth, drivewayHeight);
                ctx.strokeRect(drivewayX, drivewayY, drivewayWidth, drivewayHeight);
                
            } else if (currentOrientation === 'east') {
                // Driveway from east side
                const drivewayX = buildingX + buildingWidth;
                const drivewayY = buildingY + buildingHeight/2 - drivewayWidth/2;
                const drivewayLength = (startX + plotLength) - (buildingX + buildingWidth);
                
                ctx.fillRect(drivewayX, drivewayY, drivewayLength, drivewayWidth);
                ctx.strokeRect(drivewayX, drivewayY, drivewayLength, drivewayWidth);
                
            } else {
                // Driveway from west side
                const drivewayX = startX;
                const drivewayY = buildingY + buildingHeight/2 - drivewayWidth/2;
                const drivewayLength = buildingX - startX;
                
                ctx.fillRect(drivewayX, drivewayY, drivewayLength, drivewayWidth);
                ctx.strokeRect(drivewayX, drivewayY, drivewayLength, drivewayWidth);
            }
        }
        
        // Draw office design
        function drawOfficeDesign(startX, startY, length, width, area) {
            // Multiple office rooms with central corridor
            const corridorWidth = Math.min(length, width) * 0.1;
            const roomCount = Math.max(4, Math.floor(area / 400));
            
            // Draw central corridor
            ctx.fillStyle = '#f1f2f6';
            ctx.fillRect(startX, startY + width/2 - corridorWidth/2, length, corridorWidth);
            ctx.strokeRect(startX, startY + width/2 - corridorWidth/2, length, corridorWidth);
            
            // Draw office rooms on both sides
            const roomsPerSide = Math.ceil(roomCount / 2);
            const roomHeight = (width - corridorWidth) / 2 / roomsPerSide;
            
            // Top side rooms
            for (let i = 0; i < roomsPerSide; i++) {
                const roomWidth = length / 4;
                const roomX = startX + (i % 4) * roomWidth;
                const roomY = startY + i * roomHeight;
                
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(roomX, roomY, roomWidth, roomHeight);
                
                // Room label
                ctx.fillStyle = '#2c3e50';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Office ${i+1}`, roomX + roomWidth/2, roomY + roomHeight/2);
            }
            
            // Reception area at entrance based on orientation
            drawReceptionArea(startX, startY, length, width, corridorWidth);
        }
        
        // Draw reception area based on orientation
        function drawReceptionArea(startX, startY, length, width, corridorWidth) {
            ctx.fillStyle = 'rgba(155, 89, 182, 0.2)';
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 2;
            
            const receptionSize = Math.min(length, width) * 0.2;
            
            if (currentOrientation === 'north') {
                ctx.fillRect(startX + length/2 - receptionSize/2, startY, receptionSize, receptionSize);
                ctx.strokeRect(startX + length/2 - receptionSize/2, startY, receptionSize, receptionSize);
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('RECEPTION', startX + length/2, startY + receptionSize/2);
                
            } else if (currentOrientation === 'south') {
                ctx.fillRect(startX + length/2 - receptionSize/2, startY + width - receptionSize, receptionSize, receptionSize);
                ctx.strokeRect(startX + length/2 - receptionSize/2, startY + width - receptionSize, receptionSize, receptionSize);
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('RECEPTION', startX + length/2, startY + width - receptionSize/2);
                
            } else if (currentOrientation === 'east') {
                ctx.fillRect(startX + length - receptionSize, startY + width/2 - receptionSize/2, receptionSize, receptionSize);
                ctx.strokeRect(startX + length - receptionSize, startY + width/2 - receptionSize/2, receptionSize, receptionSize);
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('RECEPTION', startX + length - receptionSize/2, startY + width/2);
                
            } else {
                ctx.fillRect(startX, startY + width/2 - receptionSize/2, receptionSize, receptionSize);
                ctx.strokeRect(startX, startY + width/2 - receptionSize/2, receptionSize, receptionSize);
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('RECEPTION', startX + receptionSize/2, startY + width/2);
            }
        }
        
        // Draw apartment design
        function drawApartmentDesign(startX, startY, length, width, area) {
            // Multiple apartment units
            const unitsPerFloor = 4;
            const floors = Math.max(2, Math.floor(area / 2000));
            
            const unitWidth = length / 2;
            const unitHeight = width / 2;
            
            // Draw building structure
            ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.strokeRect(startX, startY, length, width);
            
            // Draw floors
            for (let floor = 0; floor < floors; floor++) {
                const floorY = startY + (floors - 1 - floor) * (width / floors);
                const floorHeight = width / floors;
                
                // Draw floor separator
                if (floor > 0) {
                    ctx.strokeStyle = '#95a5a6';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.moveTo(startX, floorY);
                    ctx.lineTo(startX + length, floorY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw units on this floor
                for (let unit = 0; unit < unitsPerFloor; unit++) {
                    const unitX = startX + (unit % 2) * unitWidth;
                    const unitY = floorY + Math.floor(unit / 2) * (floorHeight / 2);
                    
                    ctx.strokeStyle = '#3498db';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(unitX, unitY, unitWidth, floorHeight / 2);
                    
                    // Unit label
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = '9px Arial';
                    ctx.textAlign = 'center';
                    const unitNumber = floor * unitsPerFloor + unit + 1;
                    ctx.fillText(`Apt ${unitNumber}`, unitX + unitWidth/2, unitY + (floorHeight/2)/2);
                }
            }
            
            // Draw entrance and stairs based on orientation
            drawApartmentEntrance(startX, startY, length, width, floors);
        }
        
        // Draw apartment entrance based on orientation
        function drawApartmentEntrance(startX, startY, length, width, floors) {
            ctx.fillStyle = '#f39c12';
            ctx.strokeStyle = '#d35400';
            ctx.lineWidth = 2;
            
            const entranceWidth = length * 0.15;
            const entranceHeight = width * 0.1;
            
            if (currentOrientation === 'north') {
                // Entrance on north side
                ctx.fillRect(startX + length/2 - entranceWidth/2, startY, entranceWidth, entranceHeight);
                ctx.strokeRect(startX + length/2 - entranceWidth/2, startY, entranceWidth, entranceHeight);
                
                // Stairs
                for (let i = 0; i < floors; i++) {
                    const stepY = startY + entranceHeight + i * 5;
                    ctx.fillRect(startX + length/2 - entranceWidth/4, stepY, entranceWidth/2, 3);
                }
                
            } else if (currentOrientation === 'south') {
                // Entrance on south side
                ctx.fillRect(startX + length/2 - entranceWidth/2, startY + width - entranceHeight, entranceWidth, entranceHeight);
                ctx.strokeRect(startX + length/2 - entranceWidth/2, startY + width - entranceHeight, entranceWidth, entranceHeight);
                
            } else if (currentOrientation === 'east') {
                // Entrance on east side
                ctx.fillRect(startX + length - entranceHeight, startY + width/2 - entranceWidth/2, entranceHeight, entranceWidth);
                ctx.strokeRect(startX + length - entranceHeight, startY + width/2 - entranceWidth/2, entranceHeight, entranceWidth);
                
            } else {
                // Entrance on west side
                ctx.fillRect(startX, startY + width/2 - entranceWidth/2, entranceHeight, entranceWidth);
                ctx.strokeRect(startX, startY + width/2 - entranceWidth/2, entranceHeight, entranceWidth);
            }
        }
        
        // Draw warehouse design
        function drawWarehouseDesign(startX, startY, length, width, area) {
            // Simple large open space with loading docks
            ctx.fillStyle = 'rgba(149, 165, 166, 0.1)';
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 3;
            ctx.fillRect(startX, startY, length, width);
            ctx.strokeRect(startX, startY, length, width);
            
            // Internal columns
            const columnSize = Math.min(length, width) * 0.05;
            const columnsX = Math.floor(length / (width / 3));
            const columnsY = 3;
            
            ctx.fillStyle = '#7f8c8d';
            for (let x = 1; x < columnsX; x++) {
                for (let y = 1; y < columnsY; y++) {
                    const columnX = startX + x * (length / columnsX) - columnSize/2;
                    const columnY = startY + y * (width / columnsY) - columnSize/2;
                    ctx.fillRect(columnX, columnY, columnSize, columnSize);
                }
            }
            
            // Draw loading docks based on orientation
            drawLoadingDocks(startX, startY, length, width);
            
            // Office area in corner
            const officeSize = Math.min(length, width) * 0.25;
            ctx.fillStyle = 'rgba(52, 152, 219, 0.2)';
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.fillRect(startX + length - officeSize, startY, officeSize, officeSize);
            ctx.strokeRect(startX + length - officeSize, startY, officeSize, officeSize);
            
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('OFFICE', startX + length - officeSize/2, startY + officeSize/2);
        }
        
        // Draw loading docks based on orientation
        function drawLoadingDocks(startX, startY, length, width) {
            ctx.fillStyle = '#34495e';
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            
            const dockCount = 3;
            const dockWidth = length * 0.15;
            const dockHeight = width * 0.1;
            
            if (currentOrientation === 'north' || currentOrientation === 'south') {
                // Docks on north or south side
                const dockY = currentOrientation === 'north' ? startY : startY + width - dockHeight;
                
                for (let i = 0; i < dockCount; i++) {
                    const dockX = startX + (i + 1) * (length / (dockCount + 1)) - dockWidth/2;
                    ctx.fillRect(dockX, dockY, dockWidth, dockHeight);
                    ctx.strokeRect(dockX, dockY, dockWidth, dockHeight);
                    
                    // Dock door
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(dockX + dockWidth/2 - 10, dockY + (currentOrientation === 'north' ? -5 : dockHeight), 20, 8);
                    ctx.fillStyle = '#34495e';
                }
            } else {
                // Docks on east or west side
                const dockX = currentOrientation === 'west' ? startX : startX + length - dockHeight;
                
                for (let i = 0; i < dockCount; i++) {
                    const dockY = startY + (i + 1) * (width / (dockCount + 1)) - dockWidth/2;
                    ctx.fillRect(dockX, dockY, dockHeight, dockWidth);
                    ctx.strokeRect(dockX, dockY, dockHeight, dockWidth);
                    
                    // Dock door
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(dockX + (currentOrientation === 'west' ? -5 : dockHeight), dockY + dockWidth/2 - 10, 8, 20);
                    ctx.fillStyle = '#34495e';
                }
            }
        }
        
        // Draw custom design
        function drawCustomDesign(startX, startY, length, width, area) {
            // Creative abstract design
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            
            // Draw curved organic shapes
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const x1 = startX + Math.random() * length * 0.8;
                const y1 = startY + Math.random() * width * 0.8;
                const radius = Math.min(length, width) * 0.1 + Math.random() * 0.1;
                
                ctx.moveTo(x1 + radius, y1);
                ctx.arc(x1, y1, radius, 0, Math.PI * 2);
            }
            ctx.stroke();
            
            // Draw innovative geometric patterns
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            
            const patternSize = Math.min(length, width) * 0.2;
            for (let x = startX + patternSize; x < startX + length; x += patternSize * 1.5) {
                for (let y = startY + patternSize; y < startY + width; y += patternSize * 1.5) {
                    drawGeometricPattern(x, y, patternSize);
                }
            }
            
            // Draw futuristic building outline
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            
            const buildingWidth = length * 0.6;
            const buildingHeight = width * 0.5;
            const buildingX = startX + (length - buildingWidth) / 2;
            const buildingY = startY + (width - buildingHeight) / 2;
            
            // Non-rectangular building shape
            ctx.beginPath();
            ctx.moveTo(buildingX, buildingY + buildingHeight * 0.3);
            ctx.lineTo(buildingX + buildingWidth * 0.3, buildingY);
            ctx.lineTo(buildingX + buildingWidth * 0.7, buildingY);
            ctx.lineTo(buildingX + buildingWidth, buildingY + buildingHeight * 0.3);
            ctx.lineTo(buildingX + buildingWidth, buildingY + buildingHeight);
            ctx.lineTo(buildingX, buildingY + buildingHeight);
            ctx.closePath();
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        // Draw geometric pattern for custom design
        function drawGeometricPattern(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            
            // Rotating squares pattern
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 8);
                ctx.strokeRect(-size/4, -size/4, size/2, size/2);
            }
            
            ctx.restore();
        }
        
        // Draw dimension markers
        function drawDimensionMarkers(startX, startY, length, width, actualLength, actualWidth) {
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            
            // Top dimension
            const dimY = startY - 15;
            ctx.beginPath();
            ctx.moveTo(startX, dimY);
            ctx.lineTo(startX + length, dimY);
            ctx.stroke();
            
            // Top arrows
            drawArrow(startX, dimY, startX, startY);
            drawArrow(startX + length, dimY, startX + length, startY);
            
            // Top text
            ctx.fillText(`${actualLength} ft`, startX + length/2, dimY - 5);
            
            // Left dimension
            const dimX = startX - 15;
            ctx.beginPath();
            ctx.moveTo(dimX, startY);
            ctx.lineTo(dimX, startY + width);
            ctx.stroke();
            
            // Left arrows
            drawArrow(dimX, startY, startX, startY);
            drawArrow(dimX, startY + width, startX, startY + width);
            
            // Left text (rotated)
            ctx.save();
            ctx.translate(dimX - 10, startY + width/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText(`${actualWidth} ft`, 0, 0);
            ctx.restore();
        }
        
        // Draw arrow
        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 8;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI/6), toY - headLength * Math.sin(angle - Math.PI/6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI/6), toY - headLength * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }
        
        // Draw blueprint info
        function drawBlueprintInfo(startX, startY, length, width, actualLength, actualWidth, area) {
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ARCHITECTURAL BLUEPRINT', startX, startY + width + 30);
            
            ctx.font = '14px Arial';
            ctx.fillText(`Dimensions: ${actualLength}ft × ${actualWidth}ft`, startX, startY + width + 50);
            ctx.fillText(`Area: ${area.toLocaleString()} sqft`, startX, startY + width + 70);
            ctx.fillText(`Orientation: ${currentOrientation.toUpperCase()} facing`, startX, startY + width + 90);
            ctx.fillText(`Structure: ${structureTypeSelect.options[structureTypeSelect.selectedIndex].text}`, startX, startY + width + 110);
            
            // Draw scale indicator
            const scale = length / actualLength;
            ctx.textAlign = 'right';
            ctx.fillText(`Scale: 1ft = ${(1/scale * 100).toFixed(0)}px`, startX + length, startY + width + 30);
            
            // Draw north indicator
            ctx.textAlign = 'center';
            ctx.fillStyle = '#e74c3c';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('N', startX + length - 30, startY - 10);
            
            // Draw north arrow
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX + length - 30, startY - 20);
            ctx.lineTo(startX + length - 30, startY - 40);
            ctx.lineTo(startX + length - 25, startY - 35);
            ctx.moveTo(startX + length - 30, startY - 40);
            ctx.lineTo(startX + length - 35, startY - 35);
            ctx.stroke();
        }
        
        // Initialize the application
        function init() {
            resizeCanvas();
            initEventListeners();
            updateArea();
            drawBlueprint();
        }
        
        // Start the application
        window.onload = init;
    </script>
</body>
</html>